#version 460 core

// inputs
layout(rgba32f, binding = 0) uniform image2D screen;

struct Sphere {
	vec3 pos;
	float rad;
};

//layout(std430, binding = 1) buffer spheres_buffer {
//	Sphere spheres[];
//};
//uniform int spheres_max;


struct Ray {
    vec3 origin;
    vec3 dir;
};

struct HitRecord {
	bool hit;
	vec3 point;
	vec3 normal;
	float dist;
};

HitRecord intersectSphere(int sIndex, Ray r);

uniform mat4 cam_matrix;
uniform vec3 cam_pos;
uniform vec2 plane_dims;
uniform float near_plane;
uniform float far_plane;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main() {
	ivec2 output_dims = imageSize(screen);
	ivec2 p = ivec2(gl_GlobalInvocationID.xy);
	
	if (p.x > output_dims.x || p.y > output_dims.y) {
		return;
	}

	vec4 pixel = vec4(0.075, 0.133, 0.173, 1.0);
	
	vec2 uv = vec2(0, 0);
    uv.x = float((-float(p.x * 2.0) / output_dims.x) + 1.0); // transform to [-1.0, 1.0]
    uv.y = float((-float(p.y * 2.0) / output_dims.y) + 1.0); // transform to [-1.0, 1.0]

	vec3 screen_intersection_local = vec3(uv, 1) * vec3(plane_dims, near_plane);
    vec3 screen_intersection = vec3(cam_matrix * vec4(screen_intersection_local, 1.0));
	
	Ray ray;
	ray.origin = cam_pos;
	ray.dir = normalize(screen_intersection - ray.origin);

	HitRecord hitInfo = intersectSphere(0, ray);	

	if (hitInfo.hit == true) {
		pixel = vec4(hitInfo.normal, 1.0);
	}
	else {
		pixel = vec4(ray.dir, 1.0);
	}

	imageStore(screen, p, pixel);
}

HitRecord intersectSphere(int sIndex, Ray r) {
	//Sphere s = spheres[sIndex];
	Sphere s;
	s.pos = vec3(0.0, 0.0, 5.0);
	s.rad = 1.0;

	vec3 o = r.origin - s.pos;
	float a = dot(r.dir, r.dir);
	float half_b = dot(o, r.dir);
	float c = dot(o, o) - (s.rad * s.rad);
	float discriminant = (half_b * half_b) - (a * c);

	HitRecord hit;
	if (discriminant >= 0) {
		float sqrtd = sqrt(discriminant);
		float root = (-half_b - sqrtd) / a;
		if (root < near_plane || root > far_plane) {
			root = (-half_b + sqrtd) / a;
			if (root < near_plane || root > far_plane) {
				hit.hit = false;
				return hit;
			}
		}
		hit.hit = true;
		hit.dist = root;
		hit.point = r.origin + (root * r.dir);
		hit.normal = (hit.point - s.pos) / s.rad;
		return hit;
	}
	hit.hit = false;
	return hit;
}
