#version 460 core

#define NUM_BOUNCES 2

// inputs
layout(rgba32f, binding = 0) uniform image2D screen;

uniform vec3 cam_pos;
uniform vec2 plane_dims;
uniform float near_plane;
uniform float far_plane;

uniform mat4 inverse_view;
uniform mat4 inverse_projection;

struct Material {
	vec3 albedo;
	float roughness;
//	float metallic;
};

struct Sphere {
	vec3 pos;
	float radius;

	Material material;
};

layout(std430, binding = 1) buffer spheres_buffer {
	Sphere spheres[];
};
uniform int spheres_max;

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct HitRecord {
	bool hit;
	vec3 point;
	vec3 normal;
	float dist;
	bool front_face;

	int object_type;
	int object_index;
};
#define OBJECT_SPHERE 0

#define set_face_normal(h, r) if (dot(r.dir, h.normal) > 0.0) { \
								h.normal = -h.normal; \
								h.front_face = false; \
							  } else { \
								h.front_face = true; \
							  }

Ray createRay(vec3 origin, vec3 dir) { 
	Ray new_ray;
	new_ray.origin = origin;
	new_ray.dir = dir;
	return new_ray;
}

vec4 perPixel(Ray ray);
HitRecord intersectWorld(Ray ray);
HitRecord intersectSphere(int sIndex, Ray r);


layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main() {
	ivec2 output_dims = imageSize(screen);
	ivec2 p = ivec2(gl_GlobalInvocationID.xy);
	
	if (p.x > output_dims.x || p.y > output_dims.y) {
		return;
	}

	vec4 pixel = vec4(0.075, 0.133, 0.173, 1.0);
	
	vec2 uv = vec2(0, 0);
    uv.x = float((-float(p.x * 2.0) / output_dims.x) + 1.0); // transform to [-1.0, 1.0]
    uv.y = -float((-float(p.y * 2.0) / output_dims.y) + 1.0); // transform to [-1.0, 1.0]
	
	vec4 target = inverse_projection * vec4(uv, 1.0, 1.0);
	vec3 ray_dir = vec3(inverse_view * vec4(normalize(target.xyz / target.w), 0));

	Ray ray = createRay(cam_pos, normalize(ray_dir));

	vec4 result = perPixel(ray);

	imageStore(screen, p, result);
}

vec4 perPixel(Ray ray) {
	vec3 result = vec3(0.0, 0.0, 0.0);

	float multiplier = 1.0;

	vec3 light_dir = normalize(vec3(0, -1, 0));

	for (int b = 0; b < NUM_BOUNCES; b++) {
		
		HitRecord hit_record = intersectWorld(ray);

		// the ray didn't hit anything
		if (hit_record.hit == false) {
			vec3 sky_color = vec3(0.6, 0.7, 0.9);
			result += sky_color * multiplier;
			break;
		}
		// ray hit an object
		// get the material
		Material mat;
		switch (hit_record.object_type) {
		case OBJECT_SPHERE:
			mat = spheres[hit_record.object_index].material;
			break;
		}

		float light_intensity = max(dot(hit_record.normal, -light_dir), 0.0); // == cos(angle)

		result += mat.albedo * light_intensity * multiplier;

		multiplier *= 0.5;

		ray.origin = hit_record.point;// + hit_record.normal * 0.0001;
		ray.dir = reflect(ray.dir, hit_record.normal);
	}

	return vec4(result, 1.0);
}

HitRecord intersectWorld(Ray ray) {	
	HitRecord closestRecord;
	closestRecord.hit = false;
	closestRecord.dist = far_plane + 1.0;
	HitRecord currentRecord;

	// check for intersections with spheres
	for (int i = 0; i < spheres_max; i++) {
		currentRecord = intersectSphere(i, ray);
		if (currentRecord.hit) {
			if (currentRecord.dist < closestRecord.dist) {
				closestRecord = currentRecord;	
			}
		}
	}

	return closestRecord;
}

HitRecord intersectSphere(int sIndex, Ray r) {
	Sphere s = spheres[sIndex];

	vec3 o = r.origin - s.pos;
	float a = dot(r.dir, r.dir);
	float half_b = dot(o, r.dir);
	float c = dot(o, o) - (s.radius * s.radius);
	float discriminant = (half_b * half_b) - (a * c);

	HitRecord hit;
	if (discriminant < 0) {
		hit.hit = false;
		return hit;
	}
	float sqrtd = sqrt(discriminant);
	float root = (-half_b - sqrtd) / a;
	if (root < near_plane || root > far_plane) {
		root = (-half_b + sqrtd) / a;
		if (root < near_plane || root > far_plane) {
			hit.hit = false;
			return hit;
		}
	}
	hit.hit = true;
	hit.dist = root;
	hit.point = r.origin + (root * r.dir);
	hit.normal = (hit.point - s.pos) / s.radius;
	set_face_normal(hit, r);
	hit.object_type = OBJECT_SPHERE;
	hit.object_index = sIndex;
	return hit;
}
